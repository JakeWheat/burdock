Test: empty
Script:
Result:

Test: Trivial
Script:
a = 3
a
Result:
a = 3
a

Test: unrecognised iden
Script:
a
Errors:
unrecognised-identifier([list: "a"])

Test: import
Module:
a = 3
Result:
a = 3
make-module({a:a})

Test: import
File: imported
a = 3
Script:
import file("imported") as i
i.a
Result:
_module_file_imported = load-module("import", "file", [list:"imported"])
_module_file_imported.a

Test: import unrec
File: imported
a = 3                                                
Script:
import file("imported") as i
i.b
Errors:
unrecognised-identifier([list: "i", "b"])

Test: block
Script:
block:
  a = 3
  a
end
b = 6
block:
  b
end
Result:
block:
  a = 3
  a
end
b = 6
block:
  b
end

Test: block no escape
Script:
block:
  a = 3
end
a
Errors:
unrecognised-identifier([list: "a"])

Test: block no escape module version
Module:
a = 2
block:
  b = 3
end
c = 4
a
Result:
a = 2
block:
  b = 3
end
c = 4
a
make-module({a:a,c:c})

Test: trivial field access
Script:
a = 1
a.x
Result:
a = 1
a.x

Test: fail field access
Script:
a = 1
b.x
Errors:
unrecognised-identifier([list: "b", "x"])

Test: import field access
File: imported
a = 3        
Script:                                        
import file("imported") as i
i.a.x
Result:
_module_file_imported = load-module("import field access", "file", [list: "imported"])
_module_file_imported.a.x

Test: import field access fail
File: imported
a = 3        
Script:                                        
import file("imported") as i
i.b.x
Errors:
unrecognised-identifier([list: "i", "b", "x"])

Test: trivial shadow
Script:                                        
a = 3
a
shadow a = 4
a
Result:
a = 3
a
shadow a = 4
a

Test: needs shadow
Script:                                        
a = 3
a = 4
Errors:
identifier-redefined("a")

Test: includefrom
File: imported
a = 3
Script:
import file("imported") as i
include from i: * end
a
Result:
_module_file_imported = load-module("includefrom", "file", [list: "imported"])
_module_file_imported.a

Test: includefrom with field access
File: imported
a = 3        
Script:                                        
import file("imported") as i
include from i: * end
a.x
Result:
_module_file_imported = load-module("includefrom with field access", "file", [list: "imported"])
_module_file_imported.a.x

Test: includefrom * clash
File: imported1
a = 3        
File: imported2
a = 3        
Script:                                        
import file("imported1") as i1
import file("imported2") as i2
include from i1: * end
include from i2: * end
a.x
Errors:
identifier-redefined("a")

Test: include shadow fail
File: imported
a = 3
Script:
import file("imported") as i
include from i: * end
a = 3
a
Errors:
identifier-redefined("a")

Test: include shadow ok
File: imported
a = 3
Script:
import file("imported") as i
include from i: * end
shadow a = 3
a
i.a
Result:
_module_file_imported = load-module("include shadow ok", "file", [list: "imported"])
shadow a = 3
a
_module_file_imported.a

Test: provide all direct
Module:
provide:
  *
end
a = 3
b = 4
Result:
a = 3
b = 4
make-module({a:a, b:b})

Test: provide explicit
Module:
provide:
  a
end
a = 3
b = 4
Result:
a = 3
b = 4
make-module({a:a})

Test: provide rename
Module:
provide:
  a as c
end
a = 3
b = 4
Result:
a = 3
b = 4
make-module({c:a})

Test: provide hiding
Module:
provide:
  * hiding (a)
end
a = 3
b = 4
Result:
a = 3
b = 4
make-module({b:b})

Test: provide hiding order
Module:
provide:
  * hiding (a)
end
a = 3
b = 4
c = 5
Result:
a = 3
b = 4
c = 5
make-module({b:b,c:c})

Test: provide order
Module:
provide:
  a,
  b
end
provide:
  c,
  d
end
a = 3
b = 4
c = 5
d = 6
Result:
a = 3
b = 4
c = 5
d = 6
make-module({a:a, b:b,c:c, d:d})

Test: provide all direct
File: mymod
provide:
  *
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.a
mymod.b
Result:
_module_file_mymod = load-module("provide all direct", "file", [list: "mymod"])
_module_file_mymod.a
_module_file_mymod.b

Test: provide explicit
File: mymod
provide:
  a
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.a
Result:
_module_file_mymod = load-module("provide explicit", "file", [list: "mymod"])
_module_file_mymod.a

Test: provide explicit fail
File: mymod
provide:
  a
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.a
mymod.b
Errors:
unrecognised-identifier([list: "mymod", "b"])

Test: provide rename fail 1
File: mymod
provide:
  a as c
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.a
Errors:
unrecognised-identifier([list: "mymod", "a"])


Test: provide rename fail 2
File: mymod
provide:
  a as c
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.b
Errors:
unrecognised-identifier([list: "mymod","b"])

Test: provide rename
File: mymod
provide:
  a as c
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.c
Result:
_module_file_mymod = load-module("provide rename", "file", [list: "mymod"])
_module_file_mymod.c

Test: provide hiding fail
File: mymod
provide:
  * hiding (a)
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.a
Errors:
unrecognised-identifier([list: "mymod", "a"])

Test: provide hiding
File: mymod
provide:
  * hiding (a)
end
a = 3
b = 4
Script:
import file("mymod") as mymod
mymod.b
Result:
_module_file_mymod = load-module("provide hiding", "file", [list: "mymod"])
_module_file_mymod.b


Test: includefrom explicit
File: imported
a = 3
b = 4
d = 5
Script:
import file("imported") as i
include from i: a end
a
Result:
_module_file_imported = load-module("includefrom explicit", "file", [list: "imported"])
_module_file_imported.a

Test: includefrom explicit fail
File: imported
a = 3
b = 4
d = 5
Script:
import file("imported") as i
include from i: a end
b
Errors:
unrecognised-identifier([list: "b"])

Test: includefrom non existent
File: imported
a = 3
b = 4
d = 5
Script:
import file("imported") as i
include from i: e end
Errors:
unrecognised-identifier([list: "e"])

Test: includefrom rename
File: imported
a = 3
b = 4
d = 5
Script:
import file("imported") as i
include from i: a as b end
b
Result:
_module_file_imported = load-module("includefrom rename", "file", [list: "imported"])
_module_file_imported.a

Test: includefrom hiding
File: imported
a = 3
b = 4
d = 5
Script:
import file("imported") as i
include from i: * hiding (a) end
b
Result:
_module_file_imported = load-module("includefrom hiding", "file", [list: "imported"])
_module_file_imported.b

Test: includefrom hiding fail
File: imported
a = 3
b = 4
d = 5
Script:
import file("imported") as i
include from i: * hiding (a) end
a
Errors:
unrecognised-identifier([list: "a"])

Test: trivial type
Script:
data Test: test(a) end
a = test(3)
assert-type-compat(a :: Test)
Result:
data Test: test(a) end
a = test(3)
assert-type-compat(a :: Test)

Test: type not found
Script:
a = 3
assert-type-compat(a :: Test)
Errors:
unrecognised-identifier([list: "Test"])

Test: import type
File: imported
data Test: test(a) end
Script:
import file("imported") as i
a = 3
assert-type-compat(a :: i.Test)
Result:
_module_file_imported = load-module("import type", "file", [list: "imported"])
a = 3
assert-type-compat(a :: _module_file_imported.Test)

Test: trivial variant
Script:
data Test: test(a) end
a = test(3)
cases a:
  | test(_) => 1
end
Result:
data Test: test(a) end
a = test(3)
cases a:
  | test(_) => 1
end

Test: variant not found
Script:
data Test: test(a) end
a = test(3)
cases a:
  | test1(_) => 5
end
Errors:
unrecognised-identifier([list: "test1"])

# test disabled because it fails, because the rewrite
# gives a pattern of a 0 arg variant
# but parsing the expected value gives a name pattern
# it's a limitation of the testing framework
# Test: no arg variant OK
# Script:
# data Test: test() end
# a = test
# cases a:
#   | test => 1
# end
# Result:
# data Test: test() end
# a = test
# cases a:
#   | test => 1
# end

Test: no arg variant not found OK
Script:
data Test: test() end
a = test
cases a:
  | test1 => 1
end
Result:
data Test: test() end
a = test
cases a:
  | test1 => 1
end

Test: import variant
File: imported
data Test:
  | test(a)
  | test2
end
Script:
import file("imported") as m
include from m:
  *
end
a = test(3)
cases a:
  | test(_) => 4
  | test2 => 5
  | el => 6
end
Result:
_module_file_imported = load-module("import variant", "file", [list: "imported"])
a = _module_file_imported.test(3)
cases a:
  | _module_file_imported.test(_) => 4
  | _module_file_imported.test2 => 5
  | el => 6
end

Test: local var assign
Script:
var a = 4
a := 5
Result:
var a = 4
a := 5

Test: local var assign fail
Script:
a = 4
a := 5
Errors:
assign-to-non-var([list: "a"])

Test: import var assign
File: imported
var a = 4
Script:
import file("imported") as i
i.a := 5
Result:
_module_file_imported = load-module("import var assign", "file", [list: "imported"])
_module_file_imported.a := 5

Test: import assign fail
File: imported
a = 4
Script:
import file("imported") as i
i.a := 5
Errors:
assign-to-non-var([list: "i", "a"])

Test: functions1
Script:
a = lam(x): x + 1 end
Result:
a = lam(x): x + 1 end

Test: functions2
Script:
a = lam(x,y): x + y end
Result:
a = lam(x,y): x + y end

Test: redefined function arg
Script:
a = lam(x,x): x + x end
Errors:
identifier-redefined("x")

Test: functions careful scoping
Script:
x = lam(x,y): x + y end
Result:
x = lam(x,y): x + y end

Test: function syntax
Script:
fun f(x): x + 1 end
Result:
fun f(x): x + 1 end

Test: recursive fun
Script:
fun f(x): 1 + f(x - 1) end
Result:
fun f(x): 1 + f(x - 1) end

Test: recursive fun sanity
Script:
fun f(x): y end
Errors:
unrecognised-identifier([list: "y"])

Test: mutual recursive
Script:
rec f = lam(a): a + g(a - 1) end
rec g = lam(a): a + f(a - 1) end
Result:
rec f = lam(a): a + g(a - 1) end
rec g = lam(a): a + f(a - 1) end

Test: variant args
Script:
data Test:
  | ctor2(a,b)
end
z = 3
cases z:
  | x => x
  | ctor2(a,b) => a + b
end
Result:
data Test:
  | ctor2(a,b)
end
z = 3
cases z:
  | x => x
  | ctor2(a,b) => a + b
end

Test: nested patterns
File: imported
data Test:
  | ctor0
  | ctor2(a,b)
end
Script:
include file("imported")
z = 3
cases z:
  | ctor2(a,ctor2(ctor0,d)) => a + d
end
Result:
_module_file_imported = load-module("nested patterns", "file", [list: "imported"])
z = 3
cases z:
  | _module_file_imported.ctor2(a,_module_file_imported.ctor2(_module_file_imported.ctor0,d)) => a + d
end

Test: check more patterns
File: imported
data Test:
  | ctor0
  | ctor2(a,b)
end
Script:
include file("imported")
z = 3
cases z:
  | a => a
  | ctor2(a,ctor2(ctor0,d)) => a + d
  | b :: Test => b
  | shadow c => c
  | _ => 0
  | {a;b} => a + b
  | {a;ctor0} => a
  | {_;_} as c => c
  | 4 => 5
  | 'test' => 'test1'
end
Result:
_module_file_imported = load-module("check more patterns", "file", [list: "imported"])
z = 3
cases z:
  | a => a
  | _module_file_imported.ctor2(a,_module_file_imported.ctor2(_module_file_imported.ctor0,d)) => a + d
  | b :: _module_file_imported.Test => b
  | shadow c => c
  | _ => 0
  | {a;b} => a + b
  | {a;_module_file_imported.ctor0} => a
  | {_;_} as c => c
  | 4 => 5
  | 'test' => 'test1'
end

Test: fun decl bug
Script:
fun f(x): x end
y = 3
y
Result:
fun f(x): x end
y = 3
y

Test: fun decl bug 2
Script:
y = 3
fun f(x): x end
y
Result:
y = 3
fun f(x): x end
y

Test: fun decl bug 3
Script:
fun f(x): x end
f(3)
Result:
fun f(x): x end
f(3)


# same issue with 0 arg ctor matches ...
# Test: scoping in data decl
# Script:
# data my-list:
#   | my-link(first, rest)
#   | my-empty
# sharing:
#   method length(self):
#     cases self:
#       | my-empty => 0
#       | my-link(_,b) => 1 + b.length()
#     end
#   end
# end
# Result:
# data my-list:
#   | my-link(first, rest)
#   | my-empty
# sharing:
#   method length(self):
#     cases self:
#       | my-empty => 0
#       | my-link(_,b) => 1 + b.length()
#     end
#   end
# end

Test: scoping in data decl error
Script:
data my-list:
  | my-link(first, rest)
  | my-empty
sharing:
  method length(self):
    cases self:
      | my-empty => 0
      | my-link(_,b) => 1 + b.length()
      | my-bogus-link(a) => a
    end
  end
end
Errors:
unrecognised-identifier([list: "my-bogus-link"])

Test: scoping in data decl extras
Script:
data my-list:
  | my-link(first, rest)
  | my-empty
sharing:
  method length(self):
    is-my-list(self)
    is-my-empty(self)
    is-my-link(self)
    self.rest
  end
end
Result:
data my-list:
  | my-link(first, rest)
  | my-empty
sharing:
  method length(self):
    is-my-list(self)
    is-my-empty(self)
    is-my-link(self)
    self.rest
  end
end


