
#|

this is the code which is unconditionally loaded in every handle to
run any burdock

the system first loads the _bootstrap module, which creates the
minimum bits that are needed for the language itself

then parts of the system which should always be loaded, even when you
don't load the globals module, go here

todo: factor out bits to the correct built-in module that don't need
to be necessarily loaded=
   
users should import stuff the want to use via the globals or other
module which reexports these

|#

include _bootstrap

provide:
  *,
  # todo: add the provide module support
  # these are the contents of the _bootstrap module
  type Boolean,
  true,
  false,

  type Nothing,
  nothing,
  is-nothing,
  _casepattern-nothing,

  get-ffi-value,
  make-variant,
  is-variant,

  type Any,
  type Number,
  type String,
  type Tuple,
  type Record,
  type Function,
  is-Tuple as is-tuple,
  is-Record as is-record,
  is-Boolean as is-boolean,
  is-String as is-string,
  is-Function as is-function,
  is-Number as is-number
end

# list construct
list = {make : lam(x): x end}

raise = get-ffi-value("raise")
haskell-error = get-ffi-value("haskell-error")
haskell-undefined = get-ffi-value("haskell-undefined")

is-specific-ffi-type = get-ffi-value("is-specific-ffi-type")

equal-by-field = get-ffi-value("equal-by-field")

get-call-stack = get-ffi-value("get-call-stack")
format-call-stack = get-ffi-value("format-call-stack")

run-script = get-ffi-value("run-script")

# debugging and troubleshooting support

load-module = get-ffi-value("load-module")
show-handle-state = get-ffi-value("show-handle-state")

# user stuff that's also used in bootstrapping the system

is-Tuple = get-ffi-value("is-tuple")
is-Record = get-ffi-value("is-record")
is-Boolean = get-ffi-value("is-boolean")
is-String = get-ffi-value("is-string")
is-Number = get-ffi-value("is-number")
is-Function = get-ffi-value("is-function")
is-Any = lam(x): true end

union-recs = get-ffi-value("union-recs")

print = get-ffi-value("print")

torepr = get-ffi-value("torepr")
tostring = get-ffi-value("tostring")

string-to-number = get-ffi-value("string-to-number")
string-index-of = get-ffi-value("string-index-of")

run-task = get-ffi-value("run-task")

not = get-ffi-value("not")

data Either<a,b>:
  | left(v :: a)
  | right(v :: b)
end

data List<a>:
  | link(first :: a, rest :: List<a>)
  | empty
end


data Option<a>:
  | none
  | some(value :: a)
end

data Infinity:
  | infinity
end

# if tests are run, automatically print the results
# this is used to disable the printing when you are getting the test
# results out and printing them or using them differently yourself
# it's used by the tasty testing adaptor
var auto-print-test-results = true
# the 'api' is to use the function, don't read or write the var directly
fun set-auto-print-test-results(b):
  auto-print-test-results := b
end
# set whether tests should be run or ignored
var auto-run-tests = false
# the 'api' is to use the function, don't read or write the var directly
fun set-auto-run-tests(b):
  auto-run-tests := b
end

data ExitType:
  | exit-value
  | exit-exception
end

data MonitorRef:
    monitor-ref(a,b)
end

data MonitorDown<a,b>:
    monitor-down(tag :: a, exit-type :: ExitType, v :: b, mref :: MonitorRef)
end

# todo: do these need to be here? or can they just be in the concurrency module
spawn = get-ffi-value("spawn")
spawn-monitor = get-ffi-value("spawn-monitor")
spawn-monitor-tag = get-ffi-value("spawn-monitor-tag")
self = get-ffi-value("self")
sleep = get-ffi-value("sleep")
send = get-ffi-value("send")
async-exit = get-ffi-value("async-exit")
