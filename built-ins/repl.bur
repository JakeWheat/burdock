
#|
  way overengineered code to run a "repl engine" in a thread
  despite being overengineered, it still has issues
  todo: switch to an evaluator object which is similar to a thread
    change run-script to not use app to evaluate, so it doesn't
      create a local bindings, but modifies the top level bindings
    adjust all the weird hacky stuff added to the thread local state
      to support the current not very good approach
    then can go back to a local thing in the repl in burdockexe
    can add a demo of one running in a another thread
    -> this is a building block of job control for the repl
       and of an attach feature, where you can start a repl
       in a running burdock process and interact with the process
|#
provide:
  create-repl,
  repl-execute,
  close-repl
end

include concurrency
include either

import from _internals:
  run-script
end

#######################################

# internal messages data type

data ReplMsg:
  | run-src(ret,src)
  | error(ret, e)
  | exiting(ret)
  | exit(ret)
  | repl-down(ret,e)
  | run-src-ok(ret)
end  

#######################################

# api
# runs in the user's thread

fun create-repl():
  spawn(repl-monitor)
end

fun repl-execute(handle, src):
  send(handle, run-src(self,src))
  receive:
    | run-src-ok(r) when r == handle => nothing
    | error(r,e) when r == handle => raise(e)
    | repl-down(r,e) when r == handle => raise(e)
  end
end

fun close-repl(handle):
  send(handle, exit(self))
  receive:
    | exiting(r) when r == handle => nothing
  end
end

#######################################
# internals

fun repl-monitor():
  sm = spawn-monitor(repl-loop)
  # todo: tuple binding
  repl = sm.{0}
  rf = sm.{1}

  fun repl-down(v):
    receive as e:
      | exit(ret) => block:
          send(ret,exiting(self))
        end
      | run-src(r,_) => block:
          send(r,repl-down(self,v))
          repl-down(v)
        end
      | _ #|as e|# => block:
          repl-down(v)
        end
    end
  end

  fun repl-monitor-loop():
    receive as e:
      | run-src(ret,src) => block:
          send(repl,run-src(self,src))
          receive as e:
            | run-src-ok(r) when r == repl => block:
                send(ret, run-src-ok(self))
                repl-monitor-loop()
              end
            | error(r,e) when r == repl => block:
                send(ret, error(self,e))
                repl-monitor-loop()
              end
            | monitor-down(_,et,v,mr) when mr == rf => block:
                send(ret,repl-down(self, v))
                repl-down(v)
              end
          end
        end
      | exit(ret) => block:
          send(repl, exit(self))
          receive:
            | exiting(r) when r == repl => block:
                send(ret,exiting(self))
                # todo: wait for monitor down signal instead of using
                # an exiting message
              end
          end
        end
      | monitor-down(_,_et,v,mr) when mr == rf => block:
          print("repl-loop unexpectedly exited: " + torepr(v))
          repl-down(v)
        end
      | _ #|as e|# => print("repl-monitor: unexpected message: " + torepr(e))
    end
  end
  repl-monitor-loop()
end

fun repl-loop():
  receive as e:
    | run-src(ret,src) => block:
        v = catch-as-either(run-script(src))
        cases v:
          | left(e) => print("Error: " + torepr(e))
          | right(v) when v == nothing => nothing
          | right(v) => print(tostring(v))
        end
        send(ret, run-src-ok(self))
        repl-loop()
      end
    | exit(ret) => block:
        send(ret, exiting(self))
      end
    | _ #|as e|# => block:
        print("repl-loop: unexpected message: " + torepr(e))
        repl-loop()
      end
  end
end

