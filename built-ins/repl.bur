
#|
  way overengineered code to run a "repl engine" in a thread
  despite being overengineered, it still has issues
  todo: switch to an evaluator object which is similar to a thread
    change run-script to not use app to evaluate, so it doesn't
      create a local bindings, but modifies the top level bindings
    adjust all the weird hacky stuff added to the thread local state
      to support the current not very good approach
    then can go back to a local thing in the repl in burdockexe
    can add a demo of one running in a another thread
    -> this is a building block of job control for the repl
       and of an attach feature, where you can start a repl
       in a running burdock process and interact with the process

  there's some serious issues using it, e.g.:
  a = 5
  then repeat:
  a
  b
  after a few repeats, it starts to go wrong
    make sure to kill it because it can use a lot of memory very quickly
  tail calls?
  unintended laziness?
  something to do with the concurrency system?
  no idea what the issue is

|#

provide:
  create-repl,
  repl-execute,
  close-repl
end

include concurrency
include either

import from _internals:
  run-script
end

#######################################

# internal messages data type

data ReplMsg:
  | run-src(ret,src)
  | error(ret, e)
  | exiting(ret)
  | exit(ret)
  | repl-down(ret,e)
  | run-src-ok(ret, v)
end  

#######################################

# api
# runs in the user's thread

fun create-repl():
  spawn(repl-monitor)
end

fun repl-execute(handle, src):
  send(handle, run-src(self,src))
  receive:
    | run-src-ok(r,v) when r == handle =>
        cases v:
          | left(e) => print("Error: " + torepr(e))
          | right(v) when v == nothing => nothing
          | right(v) => print(tostring(v))
        end
    | error(r,e) when r == handle => raise(e)
    | repl-down(r,e) when r == handle => raise(e)
  end
end

fun close-repl(handle):
  send(handle, exit(self))
  receive:
    | exiting(r) when r == handle => nothing
  end
end

#######################################
# internals

fun repl-monitor():
  {repl;rf} = spawn-monitor(repl-loop)

  fun repl-down(v):
    receive block:
      | exit(ret) => send(ret,exiting(self))
      | run-src(r,_) =>
          send(r,repl-down(self,v))
          repl-down(v)
      | _ as e => repl-down(v)
    end
  end

  fun repl-monitor-loop():
    receive block:
      | run-src(ret,src) =>
          send(repl,run-src(self,src))
          receive block:
            | run-src-ok(r, v) when r == repl =>
                send(ret, run-src-ok(self, v))
                repl-monitor-loop()
            | error(r,e) when r == repl =>
                send(ret, error(self,e))
                repl-monitor-loop()
            | monitor-down(_,et,v,mr) when mr == rf =>
                send(ret,repl-down(self, v))
                repl-down(v)
          end
      | exit(ret) =>
          send(repl, exit(self))
          receive block:
            | monitor-down(_,et,"exiting",mr) when mr == rf =>
                send(ret,exiting(self))
            | monitor-down(_,et,v,mr) when mr == rf =>
                print("repl didn't exit nicely: " + torepr(et,v))            
                send(ret,exiting(self))
          end
      | monitor-down(_,_et,v,mr) when mr == rf =>
          print("repl-loop unexpectedly exited: " + torepr(v))
          repl-down(v)
      | _ as e =>
          print("repl-monitor: unexpected message: " + torepr(e))
          repl-monitor-loop()
    end
  end
  repl-monitor-loop()
end

fun repl-loop():
  receive block:
    | run-src(ret,src) =>
        v = run-task(run-script(src))
        send(ret, run-src-ok(self, v))
        repl-loop()
    | exit(ret) => "exiting"
    | _ as e =>
        print("repl-loop: unexpected message: " + torepr(e))
        repl-loop()
  end
end

