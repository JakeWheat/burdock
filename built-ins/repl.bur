
#|

  repl in a thread
  maybe a bit overengineered for a simpler repl, but a good starting
  point for a job control enabled repl

  todo: switch to an evaluator object which is similar to a thread
    change run-script to not use app to evaluate, so it doesn't
      create a local bindings, but modifies the top level bindings
    adjust all the weird hacky stuff added to the thread local state
      to support the current not very good approach
    do an attach feature, where you can start a repl
      in a running burdock process and interact with the process
      - as long as the process enables listening on a port to
      support this
    fix the bug:

  there's some serious issues using it, e.g.:
  a = 5
  then repeat:
  a
  b
  after a few repeats, it starts to go wrong
    make sure to kill it because it can use a lot of memory very quickly
  needs explicit tail call optimisation in the interpreter?
  unintended laziness?
  something to do with the concurrency system?
  no idea what the issue is
    it seems to only happen if you keep getting exceptions
    and doesn't happen if you keep running statements that complete
      without exceptions?

|#

provide:
  create-repl,
  repl-execute,
  close-repl
end

include concurrency
include either

import from _internals:
  run-script
end

#######################################

# internal messages data type

data ReplMsg:
  | run-src(ret,src)
  | error(ret, e)
  | exiting(ret)
  | exit(ret)
  | repl-down(ret,e)
  | run-src-ok(ret, v)
end  

#######################################

# api
# runs in the user's thread

fun create-repl():
  spawn(repl-monitor)
end

fun repl-execute(handle, src):
  send(handle, run-src(self,src))
  receive:
    | run-src-ok(r,v) when r == handle =>
        cases v:
          | left(e) => print("Error: " + torepr(e))
          | right(v) when v == nothing => nothing
          | right(v) => print(tostring(v))
        end
    | error(r,e) when r == handle => raise(e)
    | repl-down(r,e) when r == handle => raise(e)
  end
end

fun close-repl(handle):
  send(handle, exit(self))
  receive:
    | exiting(r) when r == handle => nothing
  end
end

#######################################
# internals

fun repl-monitor():
  {repl;rf} = spawn-monitor(repl-loop)

  fun repl-down(v):
    receive block:
      | exit(ret) => send(ret,exiting(self))
      | run-src(r,_) =>
          send(r,repl-down(self,v))
          repl-down(v)
      | _ as e => repl-down(v)
    end
  end

  fun repl-monitor-loop():
    receive block:
      | run-src(ret,src) =>
          send(repl,run-src(self,src))
          receive block:
            | run-src-ok(r, v) when r == repl =>
                send(ret, run-src-ok(self, v))
                repl-monitor-loop()
            | error(r,e) when r == repl =>
                send(ret, error(self,e))
                repl-monitor-loop()
            | monitor-down(_,et,v,mr) when mr == rf =>
                send(ret,repl-down(self, v))
                repl-down(v)
          end
      | exit(ret) =>
          send(repl, exit(self))
          receive block:
            | monitor-down(_,et,"exiting",mr) when mr == rf =>
                send(ret,exiting(self))
            | monitor-down(_,et,v,mr) when mr == rf =>
                # todo: it's no good to print in this thread,
                # it should send it to the client thread to print
                print("repl didn't exit nicely: " + torepr(et,v))            
                send(ret,exiting(self))
          end
      | monitor-down(_,_et,v,mr) when mr == rf =>
          # todo: printing in wrong thread, see above
          print("repl-loop unexpectedly exited: " + torepr(v))
          repl-down(v)
      | _ as e =>
          # todo: printing in wrong thread, see above
          print("repl-monitor: unexpected message: " + torepr(e))
          repl-monitor-loop()
    end
  end
  repl-monitor-loop()
end

fun repl-loop():
  receive block:
    | run-src(ret,src) =>
        v = run-task(run-script(src))
        send(ret, run-src-ok(self, v))
        repl-loop()
    | exit(ret) => "exiting"
    | _ as e =>
          # todo: printing in wrong thread, see above
        print("repl-loop: unexpected message: " + torepr(e))
        repl-loop()
  end
end

