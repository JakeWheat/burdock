include concurrency
import concurrency-internals as ci
include either
import from _internals:
  haskell-error
end

check "exit value of thread":

  fun f():
    {exit:123}
  end

  h = spawn(f)

  wait(h) is {exit:123}

  h1 = spawn(f)

  wait-either(h1) is right({exit:123})

end

check "error exit value of thread":

  fun f():
    raise({exit:123})
  end

  # use no link, because if a linked spawned thread (the default)
  # exits with error, it asynchronously exits the thread that spawned it
  h = spawn-nolink(f)

  wait-either(h) is left({exit:123})

  fun shadow f():
    haskell-error("a haskell exception")
  end

  shadow h = spawn-nolink(f)

  r = wait-either(h)
  is-left(r) is true
  string-index-of(r.v, "a haskell exception") is-not -1


  fun check-wait-throw():
    fun shadow f():
      raise("thread exception")
    end

    shadow h = spawn-nolink(f)
    wait(h)
    nothing
  end

  check-wait-throw() raises "thread exception"

end


check "self, simple send and receive":

  fun f():
    cases receive-any():
    #receive:
      | {ret;"hello"} =>
        send(ret, {self;"hello to you"})
      | x =>
        raise("expected {_;'hello'}, got " + torepr(x))
    end
  end

  h = spawn(f)
  send(h, {self;"hello"})
  #receive:
  cases receive-any():
    | {frm;"hello to you"} =>
      frm is h
    | x =>
      raise("expected {_;'hello to you'}, got " + torepr(x))
  end
  wait(h)

end

check "cancel thread exit value":

  fun f():
    sleep(10)
  end

  x = spawn-nolink(f)
  thread-cancel(x)
  wait-either(x) is left("AsyncCancelled")

end



check "scoped thread exiting":

#|

spawn outer thread
spawn inner thread

the main thread gets the handle to the inner thread

outer exchanges messages with inner
outer exits
see the inner one exited
 - check the handle with wait-either


|#

  #print("main: " + torepr(ci.haskell-thread-id()))

  fun inner():
    #print("inner: " + torepr(ci.haskell-thread-id()))
    cases receive-any():
      | {ret;"hello"} => send(ret,"hello")
    end
    sleep(5)
  end

  outer-self = self

  fun outer():
    #print("outer: " + torepr(ci.haskell-thread-id()))
    h = spawn-nolink(inner)
    send(outer-self, {"inner-address"; h})
    send(h, {self;"hello"})
    cases receive-any():
      | "hello" => nothing
    end
    #print("exit outer")
  end

  h1 = spawn(outer)
  ih = cases receive-any():
         | {"inner-address";ih} =>
           wait-either(ih) is left("AsyncCancelled")
           ih
       end
  wait(h1)
  wait-either(ih)

end
