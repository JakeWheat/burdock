include concurrency
import concurrency-internals as ci
include either
import from _internals:
  haskell-error
end

check "exit value of thread":

  fun f():
    {exit:123}
  end

  h = spawn(f)

  wait(h) is {exit:123}

  h1 = spawn(f)

  wait-either(h1) is right({exit:123})

end

check "error exit value of thread":

  fun f():
    raise({exit:123})
  end

  # use no link, because if a linked spawned thread (the default)
  # exits with error, it asynchronously exits the thread that spawned it
  h = spawn-nolink(f)

  wait-either(h) is left({exit:123})

  fun shadow f():
    haskell-error("a haskell exception")
  end

  shadow h = spawn-nolink(f)

  r = wait-either(h)
  is-left(r) is true
  string-index-of(r.v, "a haskell exception") is-not -1


  fun check-wait-throw():
    fun shadow f():
      raise("thread exception")
    end

    shadow h = spawn-nolink(f)
    wait(h)
    nothing
  end

  check-wait-throw() raises "thread exception"

end


check "self, simple send and receive":

  fun f():
    cases receive-any():
    #receive:
      | {ret;"hello"} =>
        send(ret, {self;"hello to you"})
      | x =>
        raise("expected {_;'hello'}, got " + torepr(x))
    end
  end

  h = spawn(f)
  send(h, {self;"hello"})
  #receive:
  cases receive-any():
    | {frm;"hello to you"} =>
      frm is h
    | x =>
      raise("expected {_;'hello to you'}, got " + torepr(x))
  end
  wait(h)

end

check "cancel thread exit value":

  fun f():
    receive-any()
  end

  x = spawn-nolink(f)
  thread-cancel(x)
  wait-either(x) is left(cancelled(nothing))

end

check "scoped thread exiting simple":

#|

spawn outer thread
spawn inner thread

the main thread gets the handle to the inner thread

outer exchanges messages with inner
outer exits
see the inner one exited
 - check the handle with wait-either


|#

  #print("main: " + torepr(ci.haskell-thread-id()))

  fun inner():
    #print("inner: " + torepr(ci.haskell-thread-id()))
    cases receive-any():
      | {ret;"hello"} => send(ret,"hello")
    end
    receive-any()
  end

  outer-self = self

  fun outer():
    #print("outer: " + torepr(ci.haskell-thread-id()))
    h = spawn-nolink(inner)
    send(outer-self, {"inner-address"; h})
    send(h, {self;"hello"})
    cases receive-any():
      | "hello" => nothing
    end
    #print("exit outer")
  end

  h1 = spawn(outer)
  ih = cases receive-any():
         | {"inner-address";ih} =>
           wait-either(ih) is left(scoped-cancelled)
           ih
       end
  wait(h1)
  wait-either(ih)

end

check "scoped thread exiting cancel":

  fun inner():
    cases receive-any():
      | {ret;"hello"} => send(ret,"hello")
    end
    receive-any()
  end

  outer-self = self

  fun outer():
    h = spawn-nolink(inner)
    send(h, {self;"hello"})
    cases receive-any():
      | "hello" => nothing
    end
    send(outer-self, {"inner-address"; h})
    receive-any()
  end

  h1 = spawn-nolink(outer)
  ih = cases receive-any():
         | {"inner-address";ih} =>
           thread-cancel(h1)
           wait-either(ih) is left(scoped-cancelled)
           ih
       end
  wait-either(h1)
  wait-either(ih)

end

check "linked thread exiting":
  block:

    fun inner():
      raise("inner exiting")
    end
    
    fun outer():
      h = spawn(inner)
      receive-any()
    end
    
    h = spawn-nolink(outer)
    wait-either(h) is left(linked-cancelled("inner exiting"))
    
  end

  block:

    fun inner():
      receive-any()
    end

    outer-self = self
    fun outer():
      h = spawn-unscoped(inner)
      send(outer-self, h)
      raise("outer exiting") 
    end
    
    h = spawn-nolink(outer)
    hinner = receive-any()
    wait-either(hinner) is left(linked-cancelled("outer exiting"))
    
  end
  # if a linked thread exits with regular value, no linked threads
  # are cancelled
  block:

    fun inner():
      "OK exit"
    end
    
    fun outer():
      h = spawn(inner)
      # todo: use better coordination
      sleep(0.01)
      "OK"
    end
    
    h = spawn-nolink(outer)
    wait-either(h) is right("OK")
    
  end

  block:

    fun inner():
      receive-any()
      "OK"
    end

    outer-self = self
    fun outer():
      h = spawn-unscoped(inner)
      send(outer-self, h)
      "outer OK"
    end
    
    h = spawn-nolink(outer)
    hinner = receive-any()
    wait(h)
    send(hinner, "exit now")
    wait-either(hinner) is right("OK")
    
  end

end

check "spawnmonitor":

  # spawn monitor with normal exit
  block:
    fun f():
      receive-any()
      "normal-exit"
    end
    {sub;mref} = spawn-monitor(f)
    receive-any-timeout(0) is nothing
    send(sub, true)
    receive-any() is monitor-down(nothing,right("normal-exit"),mref)

  end
  # spawn monitor with error exit
  block:
    fun f():
      receive-any()
      raise("error-exit")
    end
    {sub;mref} = spawn-monitor(f)
    receive-any-timeout(0) is nothing
    send(sub, true)
    receive-any() is monitor-down(nothing,left("error-exit"),mref)

  end

  # spawn monitor tag with normal exit

  block:
    fun f():
      receive-any()
      "normal-exit"
    end
    {sub;mref} = spawn-monitor-tag(f,"my-tag")
    receive-any-timeout(0) is nothing
    send(sub, true)
    receive-any() is monitor-down("my-tag",right("normal-exit"),mref)

  end

  # spawn monitor tag with error exit

  block:
    fun f():
      receive-any()
      raise("error-exit")
    end
    {sub;mref} = spawn-monitor-tag(f,"my-tag")
    receive-any-timeout(0) is nothing
    send(sub, true)
    receive-any() is monitor-down("my-tag",left("error-exit"),mref)

  end

  # check spawn-monitor 2 functions, the mrefs are not equal

  block:
    fun f():
      nothing
    end
    {sub;mref} = spawn-monitor(f)
    {sub1;mref1} = spawn-monitor(f)
    mref is-not mref1

    wait(sub)
    wait(sub1)
    
  end


end

check "async exits":

  # throw a value, get it out

  block:
    fun f():
      receive-any()
    end

    x = spawn-nolink(f)
    # should you be able to exit a thread with a regular exception or
    # with a non error value?
    thread-cancel-with(x, "my-val")
    wait-either(x) is left(cancelled("my-val"))
    
  end

  # self exit

  block:
    fun f():
      thread-cancel-with(self, "x")
    end

    x = spawn-nolink(f)
    wait-either(x) is left(cancelled("x"))
    
  end


  # TODO: check run-task doesn't catch these exceptions

end