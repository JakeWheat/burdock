
data Point:
  | pt(x, y)
end
   
p1 = pt(1,2)

check:
  is-pt(p1) is true
  is-Point(p1) is true
  is-Point(1) is false
  #is-Point({1;3}) is false
  p1.x is 1
  p1.y is 2
end

data Nowt:
  | nowt
end

n1 = nowt
check:
  is-Nowt(n1) is true
  is-nowt(n1) is true
  n1 is nowt
end

data Two:
  | pt1(x, y)
  | pt2(x, y)
end

t1 = pt1(1,2)
t2 = pt2(3,4)

check:
  t1 is pt1(1,2)
  t2 is pt2(3,4)
  t1 == pt1(3,4) is false
end


#fun pf(a,n):
pf = lam(a,n):
  cases a:
    | pt1(x,y) => if n == 0: x else: y end
    | pt2(x,y) => if n == 0: x else: y end
  end
end

check:
  is-pt1(t1) is true
  is-pt2(t1) is false
  is-pt1(t2) is false
  is-pt2(t2) is true
  is-Two(t1) is true
  is-Two(t2) is true
  is-Two(p1) is false
  pf(t1,0) is 1
  pf(t1,1) is 2
  pf(t2,0) is 3
  pf(t2,1) is 4

end

data MyOption:
  | my-none
  | my-some(a)
end

check:
  #fun f(a):
  f = lam(a):
    cases a:
      | my-none => "none"
      | my-some(b) => "some" + tostring(b)
    end
  end
  x = my-none
  f(x) is "none"
  # needs the built in (global) function tostring
  # y = my-some(1)
  # f(y) is "some1"
end

 
data BTree:
  | node(value #|:: Number|#, left #|:: BTree|#, right #|:: BTree|#)
  | leaf(value #|:: Number|#)
end
check:
#where:
  a-btree = node(1, leaf(2), node(3, leaf(4), leaf(5)))

  is-BTree(a-btree) is true
  is-BTree("not-a-tree") is false
  is-BTree(leaf(5)) is true
  is-leaf(leaf(5)) is true
  is-leaf(a-btree) is false
  is-leaf("not-a-tree") is false
  is-node(leaf(5)) is false
  is-node(a-btree) is true
  is-node("not-a-tree") is false

  a-btree.value is 1
  a-btree.left.value is 2
  a-btree.right.value is 3
  a-btree.right.left.value is 4
  a-btree.right.right.value is 5

end
