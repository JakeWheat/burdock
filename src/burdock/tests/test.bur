check "plus on numbers":
  #1._plus(2) is 3
  1 + 2 is 3
  #3 + 4 is 7
end

check "simple let and let decl":

  let a = 3: a + 1 end is 4


  a = 3
  a + 1 is 4

  let shadow a = 4: a + 1 end is 5
  a is 3

  #ffi-demo(5) is 10
end

check "simple lambdas":
  f = lam(x): x + 1 end
  f(1) is 2

  a = 3
  g = lam(x): x + a end
  g(2) is 5

  h = lam(x):
        lam(y): x + y end
      end

  b = h(4)
  b(5) is 9

end

check "bits pt 1":
  x = "hello"
  #print(x)
  y = " world"
  x + y is "hello world"

  (3) is 3
end

check "bits pt 2":
  (3 + 4) * 5 is 35

  x = true
  x is true
  y = false
  y is false

  if x: 1 else: 2 end is 1
  if y: 1 else: 2 end is 2

  block:
    c = 3
    c is 3
  end

end

check "simple record":
  x = 33
  a = {a: "one", b : 2, c : x }
  a.a is "one"
  a.b is 2
  a.c is 33
end

check "simple tuple":
  t = {1;2}
  #print(t.{0})
  t.{0} is 1
  t.{1} is 2
end


check "tuple and record torepr":
  torepr({4;6}) is "{4;6}"
  torepr({a:4,b:5}) is "{a:4,b:5}"
  torepr({}) is "{}"
end

check "temp prelude with either":

  right(5) is right(5)
  left('b') is left('b')

end

data Tmp:
  | myctor
end

check "torepr":
  #print(torepr(true))
  torepr(true) is "true"
  torepr("test") is '"test"'
  tostring("test") is "test"
  torepr(5) is "5"
  torepr([list:]) is "[list: ]"
  torepr([list: 1, true]) is "[list: 1, true]"
  torepr(myctor) is "myctor"
  torepr(left(5)) is "left(5)"
  torepr(nothing) is "nothing"
  
  torepr(method(self): self.x end) is "<method>"
  torepr(lam(): true end) is "<function>"
end

check "is and is-not, equals":
  1 is 1
  1 is-not 2
  1 is-not true
  
  1.1 is 1.1
  1.1 is-not 1.12
  1.1 is-not true

  "a" is "a"
  "a" is-not "b"
  "a" is-not 1

  true is true
  true is-not false
  true is-not 1

  nothing is nothing
  nothing is-not 1

  [list: 1,2] is [list: 1,2]
  [list: 1,2] is-not [list: 2,1]
  [list: 1,2] is-not 1
  
  # data
  data MyDat:
    | ctor1
    | ctor2(a)
  end
  ctor1 is ctor1
  ctor1 is-not ctor2(1)
  ctor1 is-not 1
  ctor2(1) is ctor2(1)
  ctor2(1) is-not ctor1
  ctor2(1) is-not ctor2(2)
  ctor2(1) is-not ctor2("a")
  ctor2(1) is-not 1

  # records
  {a:1,b:2} is {a:1,b:2}
  {a:1,b:2} is {b:2,a:1}
  {a:1,b:2} is-not {a:2,b:1}
  {a:1,b:2} is-not {b:1,a:2}
  {a:1,b:2} is-not {1;2}
  {a:1,b:2} is-not 1
  {a:1,b:2,c:3} is-not {a:1,b:2}
  {} is-not {a:1}
  {} is {}
  {} is-not {1}
  {} is-not 1
  #print({})
  #print({a:1})
  #print({} == {a:1})
  # tuples
  {1;2} is {1;2}
  {1;2} is-not {2;1}
  {1;2} is-not {a:1,b:2}
  {1;2} is-not 1
  {1;2} is-not {1;2;3}

end

check "more arith, comparisons":

  4 - 3 is 1
  5 <= 4 is false
  5 < 3 is false
  5 > 3 is true

end

check "vars":

  var a = 1
  a is 1
  1 is a
  a := a + 1
  a is 2
  a := 3
  a is 3

end

check "rec decl":

  rec fact = lam(x):
    if x <= 1:  1
    else: x * fact(x - 1)
    end
  end

  fact(1) is 1
  fact(3) is 6
  fact(5) is 120


end

check "fun decl":

  fun fact(x):
    if x <= 1:  1
    else: x * fact(x - 1)
    end
  end

  fact(1) is 1
  fact(3) is 6
  fact(5) is 120


end

check "list plus":

  [list: 1,2] + [list: false,true] is [list: 1,2,false,true]

end

check "boolean ops":

  not(true) is false
  not(false) is true

  true and false is false
  true or false is true
  
  true or raise("broke") is true
  false and raise("broke") is false

end

check "when":

  var a = 1
  when true:
    a = 2
  end
  a is 2
  when false:
    a = 3
  end
  a is 2

end

check "wildcard pattern":

  a = 3
  cases a:
    | _ => 1 is 1
    | else => 1 is 2
  end

end

check "boolean literal patterns":
  cases true:
    | true => 1 is 1
    | false => 1 is 0
  end
  cases false:
    | true =>  1 is 0
    | false => 0 is 0
  end

end

check "tuple patterns":
  {x; y} = {1; 2}
  x is 1
  y is 2

  cases {3;4}:
    | {a;b} =>
      a is 3
      b is 4
    | _ => {3;4} is false
  end
end


check:
  fun list-map(lst, f):
    lst.map(f)
  end
  list-map([list:],lam(a): a end) is [list:]
  list-map([list: 1],lam(a): a end) is [list: 1]
  list-map([list: 1,2],lam(a): a end) is [list: 1,2]

  list-map([list:],lam(a): a + 1 end) is [list:]
  list-map([list: 1],lam(a): a + 1 end) is [list: 2]
  list-map([list: 1,2],lam(a): a + 1 end) is [list: 2,3]

end


data L1:
  | l1a(b)
  | l1b
end

fun f(x):
  cases x:
    | l1b => 1
    | l1a(a) => a
  end
end

fun g(x):
  cases x:
    | l1a(a) => a
    | l1b => 1
  end
end

check "no arg ctor matching":
  #print(1)
  f(l1a(3)) is 3
  f(l1b) is 1
  g(l1a(3)) is 3
  g(l1b) is 1
end

check "letrec multiple":

  fun addeven(x): if x == 0: 0 else: x + addodd(x - 1) end end
  fun addodd(x): if x == 0: 0 else: x + addeven(x - 1) end end
  addeven(6) is 21

end

data MyData:
  | my-ctor1(xx)
  | my-ctor2
sharing:
  method what(self):
    cases self:
      | my-ctor2 =>  "my-ctor2"
      | my-ctor1(_) => "my-ctor1"
    end
  end
end

check "recursion for no arg variant matching in methods":
  my-ctor1(1).what() is "my-ctor1"
  my-ctor2.what() is "my-ctor2"

end

check "debug show for list, haskell-list":
  debug-show([list:1,2,3]) is "[list: ValueNum 1,ValueNum 2,ValueNum 3]"
  debug-show([haskell-list:1,2,3]) is "[HaskellList: ValueNum 1,ValueNum 2,ValueNum 3]"
end

data OverrideToRepr:
  | override(a)
sharing:
  method _torepr(self):
    "override: " + torepr(self.a)
  end
end

check "override _torepr default method":
  torepr(override(2)) is "override: 2"
end

check "lists":

  is-list(empty) is true
  is-list(link(1, empty)) is true
  is-list(1) is false

  [list:] is empty
  [list: 1] is link(1, empty)
  [list: 1,2] is link(1,link(2, empty))
  [list: 1,2] is-not [list: 2,1]

  [list:]._torepr() is "[list: ]"
  [list:1]._torepr() is "[list: 1]"
  [list:1,2]._torepr() is "[list: 1, 2]"
  [list:1,2,3]._torepr() is "[list: 1, 2, 3]"

  torepr([list:]) is "[list: ]"
  torepr([list:1]) is "[list: 1]"
  torepr([list:1,2]) is "[list: 1, 2]"
  torepr([list:1,2,3]) is "[list: 1, 2, 3]"

  
  fun f(x):
    cases x:
      | empty => "mt"
      | link(a,b) => "link-" + torepr(a) + "-..."
    end
  end
  f(empty) is "mt"
  f([list: 1,2]) is "link-1-..."
  
  [list: 1,2].first is 1
  [list: 1,2].rest is link(2,empty)
  
  [list:] + [list:] is [list:]
  [list:] + [list: 1] is [list:1]
  [list:1] + [list:] is [list:1]
  [list:1] + [list:2] is [list:1,2]
  [list: 1,2] + [list: false,true] is [list: 1,2,false,true]

  [list:].length() is 0
  [list:1].length() is 1
  [list:1,2].length() is 2
  [list:1,2,3].length() is 3

  add-one = lam(x): x + 1 end
  
  [list:].map(add-one) is [list:]
  [list:1].map(add-one) is [list:2]
  [list:1,2].map(add-one) is [list:2,3]
  [list:1,2,3].map(add-one) is [list:2,3,4]

end
