check "plus on numbers":
  #1._plus(2) is 3
  1 + 2 is 3
  #3 + 4 is 7
end

check "simple let and let decl":

  let a = 3: a + 1 end is 4


  a = 3
  a + 1 is 4

  let shadow a = 4: a + 1 end is 5
  a is 3

  #ffi-demo(5) is 10
end

check "simple lambdas":
  f = lam(x): x + 1 end
  f(1) is 2

  a = 3
  g = lam(x): x + a end
  g(2) is 5

  h = lam(x):
        lam(y): x + y end
      end

  b = h(4)
  b(5) is 9

end

check "bits pt 1":
  x = "hello"
  #print(x)
  y = " world"
  x + y is "hello world"

  (3) is 3
end

check "bits pt 2":
  (3 + 4) * 5 is 35

  x = true
  x is true
  y = false
  y is false

  if x: 1 else: 2 end is 1
  if y: 1 else: 2 end is 2

  block:
    c = 3
    c is 3
  end

end

check "simple record":
  x = 33
  a = {a: "one", b : 2, c : x }
  a.a is "one"
  a.b is 2
  a.c is 33
end

check "simple tuple":
  t = {1;2}
  #print(t.{0})
  t.{0} is 1
  t.{1} is 2
end


check "tuple and record torepr":
  torepr({4;6}) is "{4;6}"
  torepr({a:4,b:5}) is "{a:4,b:5}"
  torepr({}) is "{}"
end

check "temp prelude with either":

  right(5) is right(5)
  left('b') is left('b')

end

data Tmp:
  | myctor
end

check "torepr":
  #print(torepr(true))
  torepr(true) is "true"
  torepr("test") is '"test"'
  tostring("test") is "test"
  torepr(5) is "5"
  torepr([list:]) is "[list: ]"
  torepr([list: 1, true]) is "[list: 1, true]"
  torepr(myctor) is "myctor"
  torepr(left(5)) is "left(5)"
  torepr(nothing) is "nothing"
  
  torepr(method(self): self.x end) is "<method>"
  torepr(lam(): true end) is "<function>"
end

check "is and is-not, equals":
  1 is 1
  1 is-not 2
  1 is-not true
  
  1.1 is 1.1
  1.1 is-not 1.12
  1.1 is-not true

  "a" is "a"
  "a" is-not "b"
  "a" is-not 1

  true is true
  true is-not false
  true is-not 1

  nothing is nothing
  nothing is-not 1

  [list: 1,2] is [list: 1,2]
  [list: 1,2] is-not [list: 2,1]
  [list: 1,2] is-not 1
  
  # data
  data MyDat:
    | ctor1
    | ctor2(a)
  end
  ctor1 is ctor1
  ctor1 is-not ctor2(1)
  ctor1 is-not 1
  ctor2(1) is ctor2(1)
  ctor2(1) is-not ctor1
  ctor2(1) is-not ctor2(2)
  ctor2(1) is-not ctor2("a")
  ctor2(1) is-not 1

  # records
  {a:1,b:2} is {a:1,b:2}
  {a:1,b:2} is {b:2,a:1}
  {a:1,b:2} is-not {a:2,b:1}
  {a:1,b:2} is-not {b:1,a:2}
  {a:1,b:2} is-not {1;2}
  {a:1,b:2} is-not 1
  {a:1,b:2,c:3} is-not {a:1,b:2}
  {} is-not {a:1}
  {} is {}
  {} is-not {1}
  {} is-not 1
  #print({})
  #print({a:1})
  #print({} == {a:1})
  # tuples
  {1;2} is {1;2}
  {1;2} is-not {2;1}
  {1;2} is-not {a:1,b:2}
  {1;2} is-not 1
  {1;2} is-not {1;2;3}

end

check "more arith, comparisons":

  4 - 3 is 1
  5 <= 4 is false
  5 < 3 is false
  5 > 3 is true

end

check "vars":

  var a = 1
  a is 1
  1 is a
  a := a + 1
  a is 2
  a := 3
  a is 3

end

check "rec decl":

  rec fact = lam(x):
    if x <= 1:  1
    else: x * fact(x - 1)
    end
  end

  fact(1) is 1
  fact(3) is 6
  fact(5) is 120


end

check "fun decl":

  fun fact(x):
    if x <= 1:  1
    else: x * fact(x - 1)
    end
  end

  fact(1) is 1
  fact(3) is 6
  fact(5) is 120


end

check "list plus":

  [list: 1,2] + [list: false,true] is [list: 1,2,false,true]

end

check "boolean ops":

  not(true) is false
  not(false) is true

  true and false is false
  true or false is true
  
  true or raise("broke") is true
  false and raise("broke") is false

end

check "when":

  var a = 1
  when true:
    a = 2
  end
  a is 2
  when false:
    a = 3
  end
  a is 2

end

check "wildcard pattern":

  a = 3
  cases a:
    | _ => 1 is 1
    | else => 1 is 2
  end

end

check "boolean literal patterns":
  cases true:
    | true => 1 is 1
    | false => 1 is 0
  end
  cases false:
    | true =>  1 is 0
    | false => 0 is 0
  end

end

check "tuple patterns":
  {x; y} = {1; 2}
  x is 1
  y is 2

  cases {3;4}:
    | {a;b} =>
      a is 3
      b is 4
    | _ => {3;4} is false
  end
end


check:
  list-map([list:],lam(a): a end) is [list:]
  list-map([list: 1],lam(a): a end) is [list: 1]
  list-map([list: 1,2],lam(a): a end) is [list: 1,2]

  list-map([list:],lam(a): a + 1 end) is [list:]
  list-map([list: 1],lam(a): a + 1 end) is [list: 2]
  list-map([list: 1,2],lam(a): a + 1 end) is [list: 2,3]

end
