
include concurrency
include option
include either

# test function
# todo: allow writing receive()?

# todo: make these tests more robust by not sharing the main process inbox
# -> run each test exclusively in a thread spawned just for that test

fun receive-any():
  receive as zz: | _ => zz end
end

pid = spawn(lam(): block:
      x = receive-any()
      send(x.ret, "hello " + x.val)
    end
  end)

send(pid, {ret:self, val:"world"})

check:
  cases 1:
    | _ => 2
  end is 2
end

check:
  cases 1:
    | _ when false => true
    | _ when true => "xxx"
  end is "xxx"
end



check:
  receive-any() is "hello world"
end

pid = spawn(lam(): block:
      x = receive-any()
      send(x, left("skip1"))
      send(x, left("skip2"))
      send(x, right("got it"))
    end
  end)

# how do you pass self to a spawned thread via the closure?
send(pid, self)

check:
  receive:
    | right(x) => x
  end is "got it"
  receive-any() is left("skip1")
  receive-any() is left("skip2")
end

fun wait-ref(mref):
  receive:
    | monitor-down(_tg,_et,v,mr) when mr == mref => v
  end
end

# sanity check:
x = spawn-monitor(lam(): "myret" end)
check:
  wait-ref(x.{1}) is "myret"
end

x = spawn-monitor(lam(): raise("myretexc") end)
check:
  wait-ref(x.{1}).{0} is "myretexc"
end






# spawn 1
# spawn 2
# spawn: tell 2 to exit
#   then tell 1 to exit - race possibility?
# wait-ref on 1
# wait-ref on 2

data Msg: msg(ret,val) end

#print("HERE1")
pid = spawn(lam(): block:
      #print("HEREa1")
      ret = receive-any()
      #print("HEREa2")
      send(ret, msg(self,2))
      send(ret, msg(self,3))
      send(ret, msg(self,4))
      #print("HEREa3")
    end
  end)
#print("HERE2")

send(pid, self)
#print("HERE3")

check:
  receive:
    | msg(ret,v) when v == 3 => 3
  end is 3
  #print("HERE4")
  x1 = receive-any()
  x2 = receive-any()
  x1.val is 2
  x2.val is 4
end
#print("HERE5")


# receive pattern matching

pid = spawn(lam(): block:
      #print("spawned1")
      receive:
        | msg(ret,val) => #block:
            #print("spawned2")
            send(ret, msg(self,"hello " + val))
            #print("spawned3")
          #end
      end
      #print("spawned4")
    end
  end)

#print("send1")
send(pid, msg(self,"world"))
#print("send2")
x = receive: | msg(_,a) => a end
#print("send3")

check:
  x is "hello world"
end

# receive timeout

# timeout 0 with nothing in the queue

x = receive:
    | msg(ret,val) => some(val)
    | after 0 => none
  end

check:
  x is none
end

# timeout 0 with something in the queue

send(self, msg(self,"stuff"))

x = receive:
    | msg(ret,val) => some(val)
    | after 0 => none
  end

check:
  x is some("stuff")
end

# timeout 1 with nothing in the queue

# timeout 1 with something posted to the queue after 0.1

# receive buffering non matching
# put a non matching then a matching
# get the matching
# get the remaining item

# timeout 1 with non matching in queue, non matching posted after 0.1
# then matching posted after another 0.1

# explicit infinity timeout
# duplicate the implicit infinity timeout test above

# check block in spawn
# redo these when do the helper to wait on a particular thread
#|
spawn(lam(): block:
    check:
      1 is 2
    end end end)

# spawn in check block

check:
  spawn(lam(): block:
      1 is 31
    end end)
end

sleep(0.4)

# the check block in spawn and spawn in check block need better
# testing than this -> assert the results include the expected test
# predicates

# spawn-monitor: exit val, exit exception
|#

check "spawn-monitor":

  _ = spawn-monitor(lam(): msg(self,"result") end)
  
  receive:
    | monitor-down(tg,et,v,mr) =>
      cases v:
        | msg(ret,val) => some(val)
        | _ => none
      end
  end is some("result")
end

check "spawn-monitor-exception":

  x = spawn-monitor(lam(): raise(msg(self,"errorthing")) end)
  
  receive:
    | monitor-down(tg,et,v,mr) => block:
        cases v.{0}:
          | msg(ret,val) => block: # todo: needs the block wrapper, fix this bug
              val is "errorthing"
            end
          | _ => none
        end
        mr is x.{1}
      end
  end

  x = spawn-monitor(lam(): raise(msg(self,"errorthing")) end)

receive:
    | monitor-down(tg,et,v,mr) => block:
        {cases v.{0}:
          | msg(ret,val) => val
          | _ => v.{0}
         end;mr}
      end
  end is {"errorthing"; x.{1}}

end

# todo with spawn-monitor:
# check the tag
# check the error type
# check the callstack when it's an exception

# spawn-monitor-tag

# async-exit + spawn-monitor exit val
