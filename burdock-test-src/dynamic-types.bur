
# testing assert-type-compat which is the internals primitive
# and type annotations in let x :: Ty = ...: ... end
# when move to checking identifiers statically, some of the tests
# below will also give static errors, which means they won't work
# as is since the test code won't run at all, one option is to use an
# eval function to wrap bits of code which fail with static checks
# another might be to use ghc style 'defer static checks' which will
# raise each static failure at runtime when you get to the line
# of code that failed the static check

check "simplest type tag checks":

  assert-type-compat(3 :: Number) is 3
  assert-type-compat('a' :: Number) raises "type not compatible"
  let x :: Number = 3: x end is 3
  let x :: Boolean = 3: x end raises "type not compatible"

  assert-type-compat(true :: Boolean) is true
  let x :: Boolean = true: x end is true

  assert-type-compat('a' :: String) is 'a'
  let x :: String = 'b': x end is 'b'

  # revisit when working on anomaly tests/ error messages
  assert-type-compat('a' :: Four) raises 'identifier not found'
  let x :: Four = 'b': x end raises 'identifier not found'
  
end

check "type-let":

  type-let x = Number: let y :: x = 3: y end end is 3
  type-let x = String: let y :: x = 3: y end end raises "type not compatible"
  
  # todo: parameterized type-let
end

check "special built in types":

  assert-type-compat({3;4} :: Tuple) is {3;4}
  assert-type-compat({3;4} :: Number) raises "type not compatible"
  assert-type-compat(2 :: Tuple) raises "type not compatible"
  assert-type-compat({a:5, b:2} :: Tuple) raises "type not compatible"
  assert-type-compat(empty :: Tuple) raises "type not compatible"
  let x :: Tuple = {true;false}: x end is {true;false}

  assert-type-compat({a:3,b:4} :: Record) is {a:3,b:4}
  assert-type-compat({a:3,b:4} :: Number) raises "type not compatible"
  assert-type-compat(2 :: Record) raises "type not compatible"
  assert-type-compat({5;6} :: Record) raises "type not compatible"
  assert-type-compat({} :: Record) is {}
  assert-type-compat(empty :: Record) raises "type not compatible"
  let x :: Record = {a:true,b:false}: x end is {a:true,b:false}

  assert-type-compat(lam(): 5 end :: Function)() is 5
  assert-type-compat({a:3,b:4} :: Function) raises "type not compatible"
  assert-type-compat(2 :: Function) raises "type not compatible"
  assert-type-compat({5;6} :: Function) raises "type not compatible"
  assert-type-compat(empty :: Function) raises "type not compatible"
  let x :: Function = lam(): 'a' end: x() end is 'a'
  
end

check "tuple and record types":

  assert-type-compat({7;4} :: {Number;Number}) is {7;4}
  assert-type-compat({7;4} :: {Number;String}) raises "type not compatible"
  assert-type-compat({7;4} :: {Number;Four}) raises 'identifier not found'
  assert-type-compat({true} :: {Boolean}) is {true}

  let x :: {Number;Number} = {7;4}: x end is {7;4}
  let x :: {Number;String} = {7;4}: x end raises "type not compatible"

  assert-type-compat({a:8,b:5} :: {a::Number,b::Number}) is {a:8,b:5}
  assert-type-compat({a:true,b:5} :: {b::Number,a::Boolean}) is {a:true,b:5}
  assert-type-compat({a:8,b:5} :: {a::Number,b::String}) raises "type not compatible"
  assert-type-compat({a:8,b:5} :: {a::Four,b::Number}) raises 'identifier not found'
  #todo: the parse error message for this is not good:
  #assert-type-compat(({a:8,b:5} :: {a::Four,b::Number})) raises 'identifier not found'
  assert-type-compat({} :: {}) is {}

  let x :: {} = {}: x end is {}
  let x :: Number = {}: x end raises "type not compatible"
  let x :: {a::Number,b::Number} = {a:8,b:5}: x end is {a:8,b:5}

end

data Pt: pt(a,b) end

check "data decl types basics":

  # only checks matching types to values, the other type checking for data
  # decls which uses desugaring is below
  assert-type-compat({7;45} :: Pt) raises "type not compatible"
  assert-type-compat(pt(1,2) :: Pt) is pt(1,2)
  assert-type-compat(empty :: List) is empty
  assert-type-compat(link(1,empty) :: List) is link(1,empty)
  assert-type-compat(3 :: List) raises "type not compatible"

  let x :: List = [List:1,2]: x end is [List: 1,2]
  
end


check "parameterized types":

  # todo: extend assert-type-compat to be able to do a complete
  # check on the value
  # plus maybe add a language flag which states which dynamic check
  # is used with all the other type annotations: shallow check like pyret
  # or full checks (at least useful for debugging/troubleshooting?)

  assert-type-compat(empty :: List<Number>) is empty
  assert-type-compat(empty :: List<Blah>) raises 'identifier not found'
  assert-type-compat(link(1,empty) :: List<Number>) is link(1,empty)

  # demostrate the type shallowing, it ignores the parameter as long
  # as it names a correct type when checking
  assert-type-compat(link(1,empty) :: List<String>) is link(1,empty)

  assert-type-compat(3 :: List<Number>) raises "type not compatible"
  
  # assert-type-compat(empty :: List<Number,Number>) raises 'wrong number of type params'
  # assert-type-compat(1 :: Number<Number>) raises 'wrong number of type params'
  
end

check "arrow types":

  # not sure how to write the arrow based type of this function
  # explicitly - needs some new syntax?
  # or could write it as 'Nothing -> Number'?
  # the new syntax could be '() -> Number', or just '-> Number'
  assert-type-compat(lam(): 5 end :: Function)() is 5

  assert-type-compat(lam(x): x + 5 end :: Number -> Number)(4) is 9

  assert-type-compat(lam(x): x + 5 end :: Number , Number -> Number)(4) raises "type not compatible"

  # only checks the types exist and the arity matches:
  assert-type-compat(lam(x): x + 5 end :: String -> String)(4) is 9

  
end

check "Any":
  let x :: Any = {}: x end is {}
  assert-type-compat(empty :: List<Any>) is empty
  assert-type-compat(1 :: List<Any>) raises "type not compatible"
  
end

check "wildcards":
  # no distinction from Any until the (static) type checker
  # let x :: _ = {}: x end is {}
  # assert-type-compat(empty :: List<_>) is empty
end


check "ffi types":
  
end

# all the other regular type annotation syntax tests:

data MyList<a>:
  | my-empty
  | my-link(my-first :: a, my-rest :: MyList<a>)
end

data MyPoint:
  | my-pt(x :: Number, y :: Number)
end

check "variant selector expressions":
  let x :: MyList = my-empty: x end is my-empty
  let x :: MyList<Any> = my-empty: x end is my-empty
  let x :: MyList<Number> = my-empty: x end is my-empty
  let x :: MyList = my-empty<Number>: x end is my-empty
  let x :: MyList = my-empty: x end is my-empty<Number> 
  let x :: MyList = my-empty<Number>: x end is my-empty<Number>

  let y :: MyList = my-link(1,my-empty): y end is my-link(1,my-empty)
  let y :: MyList<Number> = my-link(1,my-empty): y end is my-link(1,my-empty)
  let y :: MyList<Number> = my-link<Number>(1,my-empty): y end is my-link(1,my-empty)
  let y :: MyList<Number> = my-link(1,my-empty): y end is my-link<Number>(1,my-empty)
  let y :: MyList<Number> = my-link<Number>(1,my-empty): y end is my-link<Number>(1,my-empty)

  # doesn't work because of the dynamic types stripping type params before checking
  # always
  #let y :: MyList<Number> = my-link(true,my-empty): y end raises "type not compatible"
  #let y :: MyList = my-link<Number>(true,my-empty): y end raises "type not compatible"
  #let y :: Number = my-empty: y end raises "type not compatible"
  
  let y :: MyList = my-empty<Blah>: y end raises 'identifier not found'
  # let y :: MyList = my-empty<Number,Number>: y end raises 'wrong number of type params'

  # same as pyret - will check a parameterized type member is at least
  # the right type without checking for parameter consistency
  let y :: MyList = my-link(true,1): y end raises "type not compatible"

  # doesn't do a deep check, like pyret
  let y :: MyList<Number> = my-link(1,my-link(true,my-empty)): y end
    is my-link(1,my-link(true,my-empty))

  let z = my-pt(3,4): z end is my-pt(3,4)
  let z = my-pt(true,4): z end raises "type not compatible"
end

check "cases type syntax":
  # check the value is consistent with the type of the cases
  # check all the patterns are consistent with the type of the cases if given
  # check annotations of fields in patterns are checked
  #   how do these interact with the annotations on the variantdecls?
end

check "basic let sugar variations":
  #letdecl
  block:
    a :: Number = 3
    a
  end is 3
  block:
    a :: String = 3
    a
  end raises "type not compatible"

  # vardecl
  block:
    var a :: Number = 3
    a
  end is 3
  block:
    var a :: String = 3
    a
  end raises "type not compatible"

  # letrec
  #|
  letrec fact :: (Number -> Number) = lam(n):
      if n == 1: 1 else: n * fact(n - 1) end
  end: fact(5) end is 120
  letrec fact :: Number = lam(n):
      if n == 1: 1 else: n * fact(n - 1) end
  end: fact(5) end raises "type not compatible"
  |#

  
end

check "fun sugar":
  # lam
  # fundecl
  # recdecl
end

check "contracts":
  
end

check "type stmt":
  
end
