
check "simplest type tag checks":

  assert-type-compat(3 :: Number) is 3
  assert-type-compat('a' :: Number) raises "type not compatible"
  let x :: Number = 3: x end is 3
  let x :: Boolean = 3: x end raises "type not compatible"

  assert-type-compat(true :: Boolean) is true
  let x :: Boolean = true: x end is true

  assert-type-compat('a' :: String) is 'a'
  let x :: String = 'b': x end is 'b'

  # revisit when working on anomaly tests/ error messages
  assert-type-compat('a' :: Four) raises 'identifier not found'
  let x :: Four = 'b': x end raises 'identifier not found'
  
end

check "special built in types":

  assert-type-compat({3;4} :: Tuple) is {3;4}
  assert-type-compat({3;4} :: Number) raises "type not compatible"
  assert-type-compat(2 :: Tuple) raises "type not compatible"
  assert-type-compat({a:5, b:2} :: Tuple) raises "type not compatible"
  #assert-type-compat(empty :: Tuple) raises "type not compatible"
  let x :: Tuple = {true;false}: x end is {true;false}

  assert-type-compat({a:3,b:4} :: Record) is {a:3,b:4}
  assert-type-compat({a:3,b:4} :: Number) raises "type not compatible"
  assert-type-compat(2 :: Record) raises "type not compatible"
  assert-type-compat({5;6} :: Record) raises "type not compatible"
  #assert-type-compat(empty :: Record) raises "type not compatible"
  let x :: Record = {a:true,b:false}: x end is {a:true,b:false}

  assert-type-compat(lam(): 5 end :: Function)() is 5
  assert-type-compat({a:3,b:4} :: Function) raises "type not compatible"
  assert-type-compat(2 :: Function) raises "type not compatible"
  assert-type-compat({5;6} :: Function) raises "type not compatible"
  #assert-type-compat(empty :: Function) raises "type not compatible"
  let x :: Function = lam(): 'a' end: x() end is 'a'

  

  
end

check "record and tuple types":

end

check "parameterized types":

end

check "arrow types":

end